(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{670:function(e,n,t){"use strict";t.r(n),n.default="import { ColorProperty } from 'csstype';\nimport { css } from 'styled-components';\n\nexport interface InsightViewerCSSProperties {\n  '--contour-viewer-color'?: ColorProperty;\n  '--contour-viewer-focused-color'?: ColorProperty;\n  '--contour-viewer-stroke-width'?: ColorProperty;\n  '--contour-viewer-focused-stroke-width'?: ColorProperty;\n  '--contour-viewer-fill-color'?: ColorProperty;\n  '--contour-viewer-focused-fill-color'?: ColorProperty;\n\n  '--contour-drawer-color'?: ColorProperty;\n  '--contour-drawer-stroke-width'?: ColorProperty;\n  '--contour-drawer-fill-color'?: ColorProperty;\n\n  '--pin-color'?: ColorProperty;\n  '--pin-focused-color'?: ColorProperty;\n}\n\nexport const blockStyle = css`\n  --contour-viewer-color: #ffffff;\n  --contour-viewer-focused-color: rgb(255, 194, 17);\n  --contour-viewer-stroke-width: 3px;\n  --contour-viewer-focused-stroke-width: 6px;\n  --contour-viewer-fill-color: rgba(0, 0, 0, 0.2);\n  --contour-viewer-focused-fill-color: rgba(0, 0, 0, 0.4);\n\n  --contour-drawer-color: rgb(255, 224, 0);\n  --contour-drawer-stroke-width: 4px;\n  --contour-drawer-fill-color: rgba(255, 224, 0, 0.2);\n\n  --pin-color: #ffffff;\n  --pin-focused-color: rgb(255, 194, 17);\n`;\n\nexport const globalStyle = css`\n  :root {\n    ${blockStyle};\n  }\n`;\n"},674:function(e,n,t){"use strict";function o(e){return`Annotation(${e.id})`}t.d(n,"b",(function(){return o})),t.d(n,"a",(function(){return r}));const r=[{polygon:[[340.48,232.95999999999998],[265.38666666666666,232.10666666666668]],label:o,dataAttrs:{"data-category":"normal"}},{polygon:[[173.2266666666667,381.44],[276.48,400.21333333333337]],label:o,dataAttrs:{"data-category":"abnormal"}},{polygon:[[419.84000000000003,448.85333333333335],[361.81333333333333,407.04]],label:o,dataAttrs:{"data-category":"normal"}},{polygon:[[174.93333333333334,88.74666666666668],[215.89333333333335,129.70666666666665]],label:o,dataAttrs:{"data-category":"abnormal"}}]},699:function(e,n,t){"use strict";t.r(n),n.default="import { isTouchDevice } from '@lunit/is-touch-device';\nimport React, { Component, CSSProperties } from 'react';\nimport styled from 'styled-components';\nimport { FrameConsumer } from '../context/frame';\nimport { hitTestContours } from '../geom/hitTestContours';\nimport { InsightViewerGuestProps } from '../hooks/useInsightViewerSync';\nimport { Contour, Point } from '../types';\nimport { dashStroke } from './animation/dashStroke';\n\nexport interface ContourDrawerProps<T extends Contour> extends InsightViewerGuestProps {\n  width: number;\n  height: number;\n\n  /** Contour \ub370\uc774\ud130\ub97c \uc0c1\uc18d\ubc1b\uc740 Annotation \ub370\uc774\ud130 */\n  contours: T[];\n\n  /**\n   * \uadf8\ub9ac\uae30 \uae30\ub2a5 \ud65c\uc131\ud654 \uc5ec\ubd80\n   *\n   * HTMLElement\ub85c \uc785\ub825\ud560 \uacbd\uc6b0 MouseEvent\ub97c \ud574\ub2f9 HTMLElement\ub97c \uc0ac\uc6a9\ud574\uc11c \ucc98\ub9ac\ud55c\ub2e4\n   */\n  draw: boolean | HTMLElement | null;\n\n  /**\n   * \ud2b9\uc815 Contour\uc5d0 Mouse Over \ub418\uc5c8\uc744 \ub54c\n   * focusedContour\ub97c \uacb0\uc815\ud558\ub294\ub370 \ud544\uc694\ud558\ub2e4\n   */\n  onFocus: (contour: T | null) => void;\n\n  /** \uadf8\ub9ac\uae30\uac00 \uc644\ub8cc\ub418\uc5b4 \uc0c8\ub85c\uc6b4 Contour\uac00 \ubc1c\uc0dd\ud588\uc744 \ub54c */\n  onAdd: (polygon: Point[], event: MouseEvent | TouchEvent) => void;\n\n  /** \ud2b9\uc815 Contour\ub97c Click \ud574\uc11c \uc9c0\uc6b8\ub54c \ud544\uc694\ud558\ub2e4 */\n  onRemove: (contour: T) => void;\n\n  className?: string;\n  style?: CSSProperties;\n\n  /** \uadf8\ub9ac\ub294 \uacfc\uc815\uc5d0\uc11c Line\uc5d0 \ud45c\ud604\ub418\ub294 Animation\uc744 \ube44\ud65c\uc131 \uc2dc\ud0ac \uc218 \uc788\ub2e4 */\n  animateStroke?: boolean;\n\n  /**\n   * \uc811\uadfc Device \uc124\uc815\n   */\n  device?: 'all' | 'mouse-only' | 'touch-only' | 'stylus-only' | 'mouse-and-stylus';\n}\n\ninterface ContourDrawerState {\n  polygon: Point[];\n}\n\nfunction toLocal(element: HTMLElement, polygon: Point[]): string {\n  return polygon\n    .map(([x, y]) => {\n      const p = cornerstone.pixelToCanvas(element, { x, y });\n      return p.x + ',' + p.y;\n    })\n    .join(' ');\n}\n\nexport class ContourDrawerBase<T extends Contour> extends Component<ContourDrawerProps<T>, ContourDrawerState> {\n  static defaultProps: Partial<ContourDrawerProps<Contour>> = {\n    device: 'all',\n  };\n\n  private svg: SVGSVGElement | null = null;\n  private element: HTMLElement | null = null;\n  private focused: T | null = null;\n  private preventClickEvent: boolean = false;\n  private startX: number = 0;\n  private startY: number = 0;\n\n  private contentWindow: Window = window;\n\n  constructor(props: ContourDrawerProps<T>) {\n    super(props);\n\n    this.state = {\n      polygon: [],\n    };\n  }\n\n  render() {\n    return (\n      <>\n        <FrameConsumer stateRef={({ contentWindow }) => (this.contentWindow = contentWindow)} />\n        <svg\n          ref={this.svgRef}\n          role=\"figure\"\n          width={this.props.width}\n          height={this.props.height}\n          className={this.props.className}\n          style={this.props.style}\n        >\n          {this.props.cornerstoneRenderData && this.state.polygon && this.state.polygon.length > 0 && (\n            <>\n              <polyline points={toLocal(this.props.cornerstoneRenderData.element, this.state.polygon)} />\n              {this.props.animateStroke !== false && (\n                <polyline\n                  points={toLocal(this.props.cornerstoneRenderData.element, this.state.polygon)}\n                  data-highlight=\"highlight\"\n                />\n              )}\n            </>\n          )}\n        </svg>\n      </>\n    );\n  }\n\n  svgRef = (svg: SVGSVGElement) => {\n    if (svg && this.svg && this.element) {\n      this.deactivateInitialEvents();\n      this.deactivateMouseDrawEvents();\n\n      if (this.canActivate(this.props)) {\n        this.svg = svg;\n        this.element = this.getElement(this.props);\n        this.activateInitialEvents();\n      }\n    }\n\n    this.svg = svg;\n  };\n\n  componentDidMount() {\n    if (!this.svg) throw new Error('<svg> is not initialized');\n\n    if (this.canActivate(this.props)) {\n      this.element = this.getElement(this.props);\n      this.activateInitialEvents();\n    }\n  }\n\n  componentDidUpdate(prevProps: Readonly<ContourDrawerProps<T>>) {\n    if (prevProps.draw !== this.props.draw) {\n      if (this.element) {\n        this.deactivateInitialEvents();\n        this.deactivateMouseDrawEvents();\n      }\n\n      if (this.canActivate(this.props)) {\n        this.element = this.getElement(this.props);\n        this.activateInitialEvents();\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.element) {\n      this.deactivateInitialEvents();\n      this.deactivateMouseDrawEvents();\n    }\n  }\n\n  getElement = ({ draw }: Readonly<ContourDrawerProps<T>>): HTMLElement => {\n    //@ts-ignore\n    return draw instanceof this.contentWindow['HTMLElement'] ? (draw as HTMLElement) : (this.svg as HTMLElement);\n  };\n\n  canActivate = ({ draw }: Readonly<ContourDrawerProps<T>>) => {\n    return draw instanceof this.contentWindow['HTMLElement'] || draw === true;\n  };\n\n  // ---------------------------------------------\n  // initial events\n  // ---------------------------------------------\n  activateInitialEvents = () => {\n    if (!this.element) return;\n    if (this.props.device !== 'touch-only' && this.props.device !== 'stylus-only') {\n      this.element.addEventListener('mousemove', this.onMouseMoveToFindFocus);\n      this.element.addEventListener('mousedown', this.onMouseDownToStartDraw);\n    }\n    if (isTouchDevice() && this.props.device !== 'mouse-only') {\n      this.element.addEventListener('touchstart', this.onTouchStartToStartDraw);\n    }\n    this.element.addEventListener('click', this.onMouseClickToRemove);\n  };\n\n  deactivateInitialEvents = () => {\n    if (!this.element) return;\n    this.element.removeEventListener('mousemove', this.onMouseMoveToFindFocus);\n    this.element.removeEventListener('mousedown', this.onMouseDownToStartDraw);\n    this.element.removeEventListener('touchstart', this.onTouchStartToStartDraw);\n    this.element.removeEventListener('click', this.onMouseClickToRemove);\n  };\n\n  onMouseMoveToFindFocus = (event: MouseEvent) => {\n    event.stopPropagation();\n\n    this.findFocus(event.pageX, event.pageY);\n  };\n\n  findFocus = (pageX: number, pageY: number) => {\n    if (!this.props.contours || this.props.contours.length === 0 || !this.props.cornerstoneRenderData) return;\n\n    const element: HTMLElement = this.props.cornerstoneRenderData.element;\n\n    const { x, y } = cornerstone.pageToPixel(element, pageX, pageY);\n\n    this.focused = hitTestContours<T>(this.props.contours, [x, y]);\n\n    this.props.onFocus(this.focused);\n  };\n\n  onMouseClickToRemove = (event: MouseEvent) => {\n    event.stopPropagation();\n\n    if (!this.focused || this.preventClickEvent) return;\n\n    this.props.onRemove(this.focused);\n  };\n\n  // ---------------------------------------------\n  // touch draw events\n  // ---------------------------------------------\n  onTouchStartToStartDraw = (event: TouchEvent) => {\n    if (\n      (this.props.device === 'stylus-only' || this.props.device === 'mouse-and-stylus') &&\n      event.targetTouches[0].touchType !== 'stylus'\n    ) {\n      return;\n    } else if (event.targetTouches.length > 1) {\n      this.deactivateTouchDrawEvents();\n      this.activateInitialEvents();\n      this.setState((prevState) => ({\n        ...prevState,\n        polygon: [],\n      }));\n      return;\n    } else if (event.targetTouches.length !== 1) {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n    event.stopImmediatePropagation();\n\n    if (!this.props.cornerstoneRenderData) {\n      throw new Error('cornerstoneRenderEventData\ub97c \ucc3e\uc744 \uc218 \uc5c6\ub2e4!');\n    }\n\n    this.preventClickEvent = false;\n    this.startX = event.targetTouches[0].pageX;\n    this.startY = event.targetTouches[0].pageY;\n\n    this.deactivateInitialEvents();\n    this.activateTouchDrawEvents();\n\n    const element: HTMLElement = this.props.cornerstoneRenderData.element;\n\n    const { x, y } = cornerstone.pageToPixel(element, event.targetTouches[0].pageX, event.targetTouches[0].pageY);\n\n    this.setState((prevState) => ({\n      ...prevState,\n      polygon: [[x, y]],\n    }));\n  };\n\n  activateTouchDrawEvents = () => {\n    if (!this.element) return;\n    this.element.addEventListener('touchmove', this.onTouchMoveToDraw);\n    this.element.addEventListener('touchend', this.onTouchEndToEndDraw);\n    this.element.addEventListener('touchcancel', this.onTouchEndToEndDraw);\n    window.addEventListener('keydown', this.onKeyDownToCancelTouchDraw);\n  };\n\n  deactivateTouchDrawEvents = () => {\n    if (!this.element) return;\n    this.element.removeEventListener('touchmove', this.onTouchMoveToDraw);\n    this.element.removeEventListener('touchend', this.onTouchEndToEndDraw);\n    this.element.removeEventListener('touchcancel', this.onTouchEndToEndDraw);\n    window.removeEventListener('keydown', this.onKeyDownToCancelTouchDraw);\n  };\n\n  onTouchMoveToDraw = (event: TouchEvent) => {\n    if (event.targetTouches.length !== 1 || event.changedTouches.length !== 1) {\n      this.deactivateTouchDrawEvents();\n      this.activateInitialEvents();\n      this.setState((prevState) => ({\n        ...prevState,\n        polygon: [],\n      }));\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n    event.stopImmediatePropagation();\n\n    if (!this.props.cornerstoneRenderData) {\n      throw new Error('cornerstoneRenderEventData\ub97c \ucc3e\uc744 \uc218 \uc5c6\ub2e4!');\n    }\n\n    if (\n      !this.preventClickEvent &&\n      Math.max(\n        Math.abs(event.targetTouches[0].pageX - this.startX),\n        Math.abs(event.targetTouches[0].pageY - this.startY),\n      ) > 20\n    ) {\n      this.preventClickEvent = true;\n    }\n\n    const element: HTMLElement = this.props.cornerstoneRenderData.element;\n\n    const { x, y } = cornerstone.pageToPixel(element, event.targetTouches[0].pageX, event.targetTouches[0].pageY);\n\n    this.setState((prevState) => ({\n      ...prevState,\n      polygon: [...prevState.polygon, [x, y]],\n    }));\n  };\n\n  onTouchEndToEndDraw = (event: TouchEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n    event.stopImmediatePropagation();\n\n    this.deactivateTouchDrawEvents();\n    this.activateInitialEvents();\n\n    this.props.onAdd(this.state.polygon, event);\n\n    this.setState((prevState) => ({\n      ...prevState,\n      polygon: [],\n    }));\n  };\n\n  onKeyDownToCancelTouchDraw = (event: KeyboardEvent) => {\n    if (event.key.toLowerCase() === 'escape') {\n      event.preventDefault();\n      event.stopPropagation();\n      event.stopImmediatePropagation();\n\n      this.cancelTouchDraw();\n    }\n  };\n\n  cancelTouchDraw = () => {\n    this.deactivateTouchDrawEvents();\n    this.activateInitialEvents();\n\n    this.setState((prevState) => ({\n      ...prevState,\n      polygon: [],\n    }));\n  };\n\n  // ---------------------------------------------\n  // mouse draw events\n  // ---------------------------------------------\n  onMouseDownToStartDraw = (event: MouseEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n    event.stopImmediatePropagation();\n\n    if (!this.props.cornerstoneRenderData) {\n      throw new Error('cornerstoneRenderEventData\ub97c \ucc3e\uc744 \uc218 \uc5c6\ub2e4!');\n    }\n\n    this.preventClickEvent = false;\n    this.startX = event.pageX;\n    this.startY = event.pageY;\n\n    this.deactivateInitialEvents();\n    this.activateMouseDrawEvents();\n\n    const element: HTMLElement = this.props.cornerstoneRenderData.element;\n\n    const { x, y } = cornerstone.pageToPixel(element, event.pageX, event.pageY);\n\n    this.setState((prevState) => ({\n      ...prevState,\n      polygon: [[x, y]],\n    }));\n  };\n\n  activateMouseDrawEvents = () => {\n    if (!this.element) return;\n    this.element.addEventListener('mousemove', this.onMouseMoveToDraw);\n    this.element.addEventListener('mouseup', this.onMouseUpToEndDraw);\n    this.element.addEventListener('mouseleave', this.onMouseLeaveToCancelDraw);\n    window.addEventListener('keydown', this.onKeyDownToCancelMouseDraw);\n  };\n\n  deactivateMouseDrawEvents = () => {\n    if (!this.element) return;\n    this.element.removeEventListener('mousemove', this.onMouseMoveToDraw);\n    this.element.removeEventListener('mouseup', this.onMouseUpToEndDraw);\n    this.element.removeEventListener('mouseleave', this.onMouseLeaveToCancelDraw);\n    window.removeEventListener('keydown', this.onKeyDownToCancelMouseDraw);\n  };\n\n  onMouseMoveToDraw = (event: MouseEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n    event.stopImmediatePropagation();\n\n    if (!this.props.cornerstoneRenderData) {\n      throw new Error('cornerstoneRenderEventData\ub97c \ucc3e\uc744 \uc218 \uc5c6\ub2e4!');\n    }\n\n    if (\n      !this.preventClickEvent &&\n      Math.max(Math.abs(event.pageX - this.startX), Math.abs(event.pageY - this.startY)) > 20\n    ) {\n      this.preventClickEvent = true;\n    }\n\n    const element: HTMLElement = this.props.cornerstoneRenderData.element;\n\n    const { x, y } = cornerstone.pageToPixel(element, event.pageX, event.pageY);\n\n    this.setState((prevState) => ({\n      ...prevState,\n      polygon: [...prevState.polygon, [x, y]],\n    }));\n  };\n\n  onMouseUpToEndDraw = (event: MouseEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n    event.stopImmediatePropagation();\n\n    this.deactivateMouseDrawEvents();\n    this.activateInitialEvents();\n\n    this.props.onAdd(this.state.polygon, event);\n\n    this.setState((prevState) => ({\n      ...prevState,\n      polygon: [],\n    }));\n  };\n\n  onMouseLeaveToCancelDraw = (event: MouseEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n    event.stopImmediatePropagation();\n\n    this.cancelMouseDraw();\n  };\n\n  onKeyDownToCancelMouseDraw = (event: KeyboardEvent) => {\n    if (event.key.toLowerCase() === 'escape') {\n      event.preventDefault();\n      event.stopPropagation();\n      event.stopImmediatePropagation();\n\n      this.cancelMouseDraw();\n    }\n  };\n\n  cancelMouseDraw = () => {\n    this.deactivateMouseDrawEvents();\n    this.activateInitialEvents();\n\n    this.setState((prevState) => ({\n      ...prevState,\n      polygon: [],\n    }));\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport const ContourDrawer: new <T extends Contour>() => ContourDrawerBase<T> = styled(ContourDrawerBase)`\n  position: absolute;\n  top: 0;\n  left: 0;\n\n  --color: rgb(255, 224, 0);\n  --stroke-width: 4px;\n  --fill-color: rgba(255, 224, 0, 0.2);\n\n  > polyline:first-child {\n    stroke: var(--contour-drawer-color, var(--color));\n    stroke-width: var(--contour-drawer-stroke-width, var(--stroke-width));\n    fill: var(--contour-drawer-fill-color, var(--fill-color));\n  }\n\n  > polyline[data-highlight] {\n    stroke: #ffffff;\n    stroke-width: var(--contour-drawer-stroke-width, var(--stroke-width));\n    fill: transparent;\n    ${dashStroke}\n  }\n` as any;\n\n/**\n * @deprecated use ContourDrawer instead\n */\nexport const UserContourDrawer = ContourDrawer;\n"},833:function(e,n,t){"use strict";t.r(n);var o=t(666),r=t(0),s=t.n(r),i=t(674);Object(o.installWADOImageLoader)();const a={width:[600,400,1e3],height:[700,400,1e3],control:["pen",["none","pan","pen","adjust"]],wheel:["zoom",["none","zoom"]],flip:[!1],invert:[!1]};n.default=()=>{const e=Object(r.useMemo)(()=>new o.CornerstoneSingleImage("wadouri:https://fixtures.front.lunit.io/dcm-files/series/CT000010.dcm",{unload:o.unloadImage}),[]),{cornerstoneRenderData:n,updateCornerstoneRenderData:t}=Object(o.useInsightViewerSync)(),{contours:l,focusedContour:c,addContour:u,removeContour:h,focusContour:p}=Object(o.useContour)({mode:"circle"});return s.a.createElement(o.InsightViewerTestController,{options:a},({width:r,height:a,invert:d,flip:v,control:m,resetTime:w,interactions:g,setElement:f,element:C})=>s.a.createElement(o.InsightViewerContainer,{ref:f,width:r,height:a},s.a.createElement(o.CornerstoneViewer,{width:r,height:a,invert:d,flip:v,interactions:g,resetTime:w,image:e,updateCornerstoneRenderData:t}),l&&l.length>0&&n&&s.a.createElement(o.CircleViewer,{width:r,height:a,contours:l,focusedContour:c,cornerstoneRenderData:n}),l&&n&&"pen"===m&&C&&s.a.createElement(o.CircleDrawer,{width:r,height:a,contours:l,draw:"pen"===m&&C,onFocus:p,onAdd:e=>u(e,{label:i.b}),onRemove:h,cornerstoneRenderData:n})))}},834:function(e,n,t){"use strict";t.r(n),n.default="import {\n  CircleDrawer,\n  CircleViewer,\n  CornerstoneImage,\n  CornerstoneSingleImage,\n  CornerstoneViewer,\n  InsightViewerContainer,\n  InsightViewerControllerOptions,\n  InsightViewerTestController,\n  installWADOImageLoader,\n  unloadImage,\n  useContour,\n  useInsightViewerSync,\n} from '@lunit/insight-viewer';\nimport React, { useMemo } from 'react';\nimport { labelFunction } from '../../../__fixtures__/circle';\n\ninstallWADOImageLoader();\n\nconst controllerOptions: InsightViewerControllerOptions = {\n  width: [600, 400, 1000],\n  height: [700, 400, 1000],\n  control: ['pen', ['none', 'pan', 'pen', 'adjust']],\n  wheel: ['zoom', ['none', 'zoom']],\n  flip: [false],\n  invert: [false],\n};\n\nexport default () => {\n  const image: CornerstoneImage = useMemo(\n    () =>\n      new CornerstoneSingleImage(`wadouri:https://fixtures.front.lunit.io/dcm-files/series/CT000010.dcm`, {\n        unload: unloadImage,\n      }),\n    [],\n  );\n\n  const { cornerstoneRenderData, updateCornerstoneRenderData } = useInsightViewerSync();\n\n  // create contour data and user drawing behaviors\n  const { contours, focusedContour, addContour, removeContour, focusContour } = useContour({\n    mode: 'circle',\n  });\n\n  return (\n    <InsightViewerTestController options={controllerOptions}>\n      {({ width, height, invert, flip, control, resetTime, interactions, setElement, element }) => (\n        <InsightViewerContainer ref={setElement} width={width} height={height}>\n          <CornerstoneViewer\n            width={width}\n            height={height}\n            invert={invert}\n            flip={flip}\n            interactions={interactions}\n            resetTime={resetTime}\n            image={image}\n            updateCornerstoneRenderData={updateCornerstoneRenderData}\n          />\n          {contours && contours.length > 0 && cornerstoneRenderData && (\n            <CircleViewer\n              width={width}\n              height={height}\n              contours={contours}\n              focusedContour={focusedContour}\n              cornerstoneRenderData={cornerstoneRenderData}\n            />\n          )}\n          {contours && cornerstoneRenderData && control === 'pen' && element && (\n            <CircleDrawer\n              width={width}\n              height={height}\n              contours={contours}\n              draw={control === 'pen' && element}\n              onFocus={focusContour}\n              onAdd={(contour) => addContour(contour, { label: labelFunction })}\n              onRemove={removeContour}\n              cornerstoneRenderData={cornerstoneRenderData}\n            />\n          )}\n        </InsightViewerContainer>\n      )}\n    </InsightViewerTestController>\n  );\n};\n"},835:function(e,n,t){"use strict";t.r(n);var o=t(666),r=t(0),s=t.n(r),i=t(36),a=t(674);Object(o.installWADOImageLoader)();const l={width:[600,400,1e3],height:[700,400,1e3],control:["pen",["none","pan","pen","adjust"]],wheel:["zoom",["none","zoom"]],flip:[!1],invert:[!1]},c=Object(i.d)(o.CircleDrawer)`
  --contour-drawer-color: #ff0000;
  --contour-drawer-fill-color: rgba(255, 255, 255, 0.4);
  --contour-drawer-stroke-width: 7px;
`;n.default=()=>{const e=Object(r.useMemo)(()=>new o.CornerstoneSingleImage("wadouri:https://fixtures.front.lunit.io/dcm-files/series/CT000010.dcm",{unload:o.unloadImage}),[]),{cornerstoneRenderData:n,updateCornerstoneRenderData:t}=Object(o.useInsightViewerSync)(),{contours:i,focusedContour:u,addContour:h,removeContour:p,focusContour:d}=Object(o.useContour)({mode:"circle"});return s.a.createElement(o.InsightViewerTestController,{options:l},({width:r,height:l,invert:v,flip:m,control:w,wheel:g,resetTime:f,interactions:C,setElement:D,element:T})=>s.a.createElement(o.InsightViewerContainer,{ref:D,width:r,height:l},s.a.createElement(o.CornerstoneViewer,{width:r,height:l,invert:v,flip:m,interactions:C,resetTime:f,image:e,updateCornerstoneRenderData:t}),i&&i.length>0&&n&&s.a.createElement(o.CircleViewer,{width:r,height:l,contours:i,focusedContour:u,cornerstoneRenderData:n}),i&&n&&"pen"===w&&T&&s.a.createElement(c,{width:r,height:l,contours:i,draw:"pen"===w&&T,onFocus:d,onAdd:e=>h(e,{label:a.b}),onRemove:p,cornerstoneRenderData:n})))}},836:function(e,n,t){"use strict";t.r(n),n.default="import {\n  CircleDrawer,\n  CircleViewer,\n  CornerstoneImage,\n  CornerstoneSingleImage,\n  CornerstoneViewer,\n  InsightViewerContainer,\n  InsightViewerControllerOptions,\n  InsightViewerTestController,\n  installWADOImageLoader,\n  unloadImage,\n  useContour,\n  useInsightViewerSync,\n} from '@lunit/insight-viewer';\nimport React, { useMemo } from 'react';\nimport styled from 'styled-components';\nimport { labelFunction } from '../../../__fixtures__/circle';\n\ninstallWADOImageLoader();\n\nconst controllerOptions: InsightViewerControllerOptions = {\n  width: [600, 400, 1000],\n  height: [700, 400, 1000],\n  control: ['pen', ['none', 'pan', 'pen', 'adjust']],\n  wheel: ['zoom', ['none', 'zoom']],\n  flip: [false],\n  invert: [false],\n};\n\nconst CustomStyleDrawer = styled(CircleDrawer)`\n  --contour-drawer-color: #ff0000;\n  --contour-drawer-fill-color: rgba(255, 255, 255, 0.4);\n  --contour-drawer-stroke-width: 7px;\n`;\n\nexport default () => {\n  const image: CornerstoneImage = useMemo(\n    () =>\n      new CornerstoneSingleImage(`wadouri:https://fixtures.front.lunit.io/dcm-files/series/CT000010.dcm`, {\n        unload: unloadImage,\n      }),\n    [],\n  );\n\n  const { cornerstoneRenderData, updateCornerstoneRenderData } = useInsightViewerSync();\n\n  // create contour data and user drawing behaviors\n  const { contours, focusedContour, addContour, removeContour, focusContour } = useContour({\n    mode: 'circle',\n  });\n\n  return (\n    <InsightViewerTestController options={controllerOptions}>\n      {({ width, height, invert, flip, control, wheel, resetTime, interactions, setElement, element }) => (\n        <InsightViewerContainer ref={setElement} width={width} height={height}>\n          <CornerstoneViewer\n            width={width}\n            height={height}\n            invert={invert}\n            flip={flip}\n            interactions={interactions}\n            resetTime={resetTime}\n            image={image}\n            updateCornerstoneRenderData={updateCornerstoneRenderData}\n          />\n          {contours && contours.length > 0 && cornerstoneRenderData && (\n            <CircleViewer\n              width={width}\n              height={height}\n              contours={contours}\n              focusedContour={focusedContour}\n              cornerstoneRenderData={cornerstoneRenderData}\n            />\n          )}\n          {contours && cornerstoneRenderData && control === 'pen' && element && (\n            <CustomStyleDrawer\n              width={width}\n              height={height}\n              contours={contours}\n              draw={control === 'pen' && element}\n              onFocus={focusContour}\n              onAdd={(contour) => addContour(contour, { label: labelFunction })}\n              onRemove={removeContour}\n              cornerstoneRenderData={cornerstoneRenderData}\n            />\n          )}\n        </InsightViewerContainer>\n      )}\n    </InsightViewerTestController>\n  );\n};\n"},936:function(e,n,t){"use strict";t.r(n),t.d(n,"default",(function(){return l}));t(0);var o=t(62),r=t(7),s=t(89),i=t(667);const a={};function l({components:e,...n}){return Object(o.b)("wrapper",Object.assign({},a,n,{components:e,mdxType:"MDXLayout"}),Object(o.b)("h1",null,Object(o.b)("inlineCode",{parentName:"h1"},"<CircleDrawer>")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"<ContourDrawer>"),"\uc640 \ub9c8\ucc2c\uac00\uc9c0\ub85c \ub2e8\uc21c\ud788 \uadf8\ub9ac\ub294 \uae30\ub2a5\ub9cc \uc788\uace0, \uadf8\ub824\uc9c4 Contour \ub370\uc774\ud130\ub4e4\uc740 ",Object(o.b)("inlineCode",{parentName:"p"},"<CircleViewer>"),"\uc5d0\uc11c \ucc98\ub9ac\ud574\uc57c \ud55c\ub2e4."),Object(o.b)("h1",null,"API"),Object(o.b)(s.Example,{example:Object(r.d)("@lunit/insight-viewer/components/ContourDrawer",{source:t(699),filename:"src/_packages/@lunit/insight-viewer/components/ContourDrawer.tsx"}),api:!0,mdxType:"Example"}),Object(o.b)("h1",null,"Sample"),Object(o.b)(s.Example,{example:Object(r.b)("./CircleDrawer/Basic",{component:t(833),source:t(834),filename:"src/_packages/@lunit/insight-viewer/__pages__/Components/CircleDrawer/Basic.tsx"}),mdxType:"Example"},Object(o.b)(i.a,{height:720,mdxType:"InsightViewerPreview"})),Object(o.b)("h1",null,"Styling"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"<ContourDrawer>"),"\uc640 \ub9c8\ucc2c\uac00\uc9c0\ub85c CSS Variable\uc744 \ud1b5\ud574\uc11c \uc0c9\uc0c1\uc744 \ubcc0\uacbd\ud560 \uc218 \uc788\ub2e4."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"<ContourDrawer>"),"\uc640 \ub9c8\ucc2c\uac00\uc9c0\ub85c ",Object(o.b)("inlineCode",{parentName:"p"},"--contour-drawer-*"),"\uc758 \uc774\ub984\uc744 \uac00\uc9c4 \ud56d\ubaa9\ub4e4\uc5d0 \uc601\ud5a5\uc744 \ubc1b\ub294\ub2e4."),Object(o.b)(s.Example,{example:Object(r.d)("../../theme/style",{source:t(670),filename:"src/_packages/@lunit/insight-viewer/theme/style.ts"}),mdxType:"Example"}),Object(o.b)(s.Example,{example:Object(r.b)("./CircleDrawer/CustomStyle",{component:t(835),source:t(836),filename:"src/_packages/@lunit/insight-viewer/__pages__/Components/CircleDrawer/CustomStyle.tsx"}),mdxType:"Example"},Object(o.b)(i.a,{height:720,mdxType:"InsightViewerPreview"})))}l.isMDXComponent=!0}}]);
//# sourceMappingURL=12.45b5470106c6da231db7.js.map
{"version":3,"sources":["webpack:///./src/_packages/@lunit/insight-viewer/theme/style.ts?c7f2","webpack:///./src/_packages/@lunit/insight-viewer/__fixtures__/circle.ts","webpack:///./src/_packages/@lunit/insight-viewer/components/ContourDrawer.tsx?adb7","webpack:///./src/_packages/@lunit/insight-viewer/__pages__/Components/CircleDrawer/Basic.tsx","webpack:///./src/_packages/@lunit/insight-viewer/__pages__/Components/CircleDrawer/Basic.tsx?e4e2","webpack:///./src/_packages/@lunit/insight-viewer/__pages__/Components/CircleDrawer/CustomStyle.tsx","webpack:///./src/_packages/@lunit/insight-viewer/__pages__/Components/CircleDrawer/CustomStyle.tsx?2385","webpack:///./src/_packages/@lunit/insight-viewer/__pages__/Components/CircleDrawer.mdx"],"names":["labelFunction","contour","id","initialContours","polygon","label","dataAttrs","installWADOImageLoader","controllerOptions","width","height","control","wheel","flip","invert","image","useMemo","CornerstoneSingleImage","unload","unloadImage","cornerstoneRenderData","updateCornerstoneRenderData","useInsightViewerSync","contours","focusedContour","addContour","removeContour","focusContour","useContour","mode","options","resetTime","interactions","setElement","element","ref","length","draw","onFocus","onAdd","onRemove","CustomStyleDrawer","styled","CircleDrawer","layoutProps","MDXContent","components","props","mdxType","parentName","example","source","api","component","isMDXComponent"],"mappings":"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","file":"12.45b5470106c6da231db7.js","sourcesContent":["export default \"import { ColorProperty } from 'csstype';\\nimport { css } from 'styled-components';\\n\\nexport interface InsightViewerCSSProperties {\\n  '--contour-viewer-color'?: ColorProperty;\\n  '--contour-viewer-focused-color'?: ColorProperty;\\n  '--contour-viewer-stroke-width'?: ColorProperty;\\n  '--contour-viewer-focused-stroke-width'?: ColorProperty;\\n  '--contour-viewer-fill-color'?: ColorProperty;\\n  '--contour-viewer-focused-fill-color'?: ColorProperty;\\n\\n  '--contour-drawer-color'?: ColorProperty;\\n  '--contour-drawer-stroke-width'?: ColorProperty;\\n  '--contour-drawer-fill-color'?: ColorProperty;\\n\\n  '--pin-color'?: ColorProperty;\\n  '--pin-focused-color'?: ColorProperty;\\n}\\n\\nexport const blockStyle = css`\\n  --contour-viewer-color: #ffffff;\\n  --contour-viewer-focused-color: rgb(255, 194, 17);\\n  --contour-viewer-stroke-width: 3px;\\n  --contour-viewer-focused-stroke-width: 6px;\\n  --contour-viewer-fill-color: rgba(0, 0, 0, 0.2);\\n  --contour-viewer-focused-fill-color: rgba(0, 0, 0, 0.4);\\n\\n  --contour-drawer-color: rgb(255, 224, 0);\\n  --contour-drawer-stroke-width: 4px;\\n  --contour-drawer-fill-color: rgba(255, 224, 0, 0.2);\\n\\n  --pin-color: #ffffff;\\n  --pin-focused-color: rgb(255, 194, 17);\\n`;\\n\\nexport const globalStyle = css`\\n  :root {\\n    ${blockStyle};\\n  }\\n`;\\n\"","import { Contour } from '@lunit/insight-viewer';\n\nexport function labelFunction(contour: Contour): string {\n  return `Annotation(${contour.id})`;\n}\n\nexport const initialContours: Omit<Contour, 'id'>[] = [\n  {\n    polygon: [\n      [340.48, 232.95999999999998],\n      [265.38666666666666, 232.10666666666668],\n    ],\n    label: labelFunction,\n    dataAttrs: {\n      'data-category': 'normal',\n    },\n  },\n  {\n    polygon: [\n      [173.2266666666667, 381.44],\n      [276.48, 400.21333333333337],\n    ],\n    label: labelFunction,\n    dataAttrs: {\n      'data-category': 'abnormal',\n    },\n  },\n  {\n    polygon: [\n      [419.84000000000003, 448.85333333333335],\n      [361.81333333333333, 407.04],\n    ],\n    label: labelFunction,\n    dataAttrs: {\n      'data-category': 'normal',\n    },\n  },\n  {\n    polygon: [\n      [174.93333333333334, 88.74666666666668],\n      [215.89333333333335, 129.70666666666665],\n    ],\n    label: labelFunction,\n    dataAttrs: {\n      'data-category': 'abnormal',\n    },\n  },\n];\n","export default \"import { isTouchDevice } from '@lunit/is-touch-device';\\nimport React, { Component, CSSProperties } from 'react';\\nimport styled from 'styled-components';\\nimport { FrameConsumer } from '../context/frame';\\nimport { hitTestContours } from '../geom/hitTestContours';\\nimport { InsightViewerGuestProps } from '../hooks/useInsightViewerSync';\\nimport { Contour, Point } from '../types';\\nimport { dashStroke } from './animation/dashStroke';\\n\\nexport interface ContourDrawerProps<T extends Contour> extends InsightViewerGuestProps {\\n  width: number;\\n  height: number;\\n\\n  /** Contour 데이터를 상속받은 Annotation 데이터 */\\n  contours: T[];\\n\\n  /**\\n   * 그리기 기능 활성화 여부\\n   *\\n   * HTMLElement로 입력할 경우 MouseEvent를 해당 HTMLElement를 사용해서 처리한다\\n   */\\n  draw: boolean | HTMLElement | null;\\n\\n  /**\\n   * 특정 Contour에 Mouse Over 되었을 때\\n   * focusedContour를 결정하는데 필요하다\\n   */\\n  onFocus: (contour: T | null) => void;\\n\\n  /** 그리기가 완료되어 새로운 Contour가 발생했을 때 */\\n  onAdd: (polygon: Point[], event: MouseEvent | TouchEvent) => void;\\n\\n  /** 특정 Contour를 Click 해서 지울때 필요하다 */\\n  onRemove: (contour: T) => void;\\n\\n  className?: string;\\n  style?: CSSProperties;\\n\\n  /** 그리는 과정에서 Line에 표현되는 Animation을 비활성 시킬 수 있다 */\\n  animateStroke?: boolean;\\n\\n  /**\\n   * 접근 Device 설정\\n   */\\n  device?: 'all' | 'mouse-only' | 'touch-only' | 'stylus-only' | 'mouse-and-stylus';\\n}\\n\\ninterface ContourDrawerState {\\n  polygon: Point[];\\n}\\n\\nfunction toLocal(element: HTMLElement, polygon: Point[]): string {\\n  return polygon\\n    .map(([x, y]) => {\\n      const p = cornerstone.pixelToCanvas(element, { x, y });\\n      return p.x + ',' + p.y;\\n    })\\n    .join(' ');\\n}\\n\\nexport class ContourDrawerBase<T extends Contour> extends Component<ContourDrawerProps<T>, ContourDrawerState> {\\n  static defaultProps: Partial<ContourDrawerProps<Contour>> = {\\n    device: 'all',\\n  };\\n\\n  private svg: SVGSVGElement | null = null;\\n  private element: HTMLElement | null = null;\\n  private focused: T | null = null;\\n  private preventClickEvent: boolean = false;\\n  private startX: number = 0;\\n  private startY: number = 0;\\n\\n  private contentWindow: Window = window;\\n\\n  constructor(props: ContourDrawerProps<T>) {\\n    super(props);\\n\\n    this.state = {\\n      polygon: [],\\n    };\\n  }\\n\\n  render() {\\n    return (\\n      <>\\n        <FrameConsumer stateRef={({ contentWindow }) => (this.contentWindow = contentWindow)} />\\n        <svg\\n          ref={this.svgRef}\\n          role=\\\"figure\\\"\\n          width={this.props.width}\\n          height={this.props.height}\\n          className={this.props.className}\\n          style={this.props.style}\\n        >\\n          {this.props.cornerstoneRenderData && this.state.polygon && this.state.polygon.length > 0 && (\\n            <>\\n              <polyline points={toLocal(this.props.cornerstoneRenderData.element, this.state.polygon)} />\\n              {this.props.animateStroke !== false && (\\n                <polyline\\n                  points={toLocal(this.props.cornerstoneRenderData.element, this.state.polygon)}\\n                  data-highlight=\\\"highlight\\\"\\n                />\\n              )}\\n            </>\\n          )}\\n        </svg>\\n      </>\\n    );\\n  }\\n\\n  svgRef = (svg: SVGSVGElement) => {\\n    if (svg && this.svg && this.element) {\\n      this.deactivateInitialEvents();\\n      this.deactivateMouseDrawEvents();\\n\\n      if (this.canActivate(this.props)) {\\n        this.svg = svg;\\n        this.element = this.getElement(this.props);\\n        this.activateInitialEvents();\\n      }\\n    }\\n\\n    this.svg = svg;\\n  };\\n\\n  componentDidMount() {\\n    if (!this.svg) throw new Error('<svg> is not initialized');\\n\\n    if (this.canActivate(this.props)) {\\n      this.element = this.getElement(this.props);\\n      this.activateInitialEvents();\\n    }\\n  }\\n\\n  componentDidUpdate(prevProps: Readonly<ContourDrawerProps<T>>) {\\n    if (prevProps.draw !== this.props.draw) {\\n      if (this.element) {\\n        this.deactivateInitialEvents();\\n        this.deactivateMouseDrawEvents();\\n      }\\n\\n      if (this.canActivate(this.props)) {\\n        this.element = this.getElement(this.props);\\n        this.activateInitialEvents();\\n      }\\n    }\\n  }\\n\\n  componentWillUnmount() {\\n    if (this.element) {\\n      this.deactivateInitialEvents();\\n      this.deactivateMouseDrawEvents();\\n    }\\n  }\\n\\n  getElement = ({ draw }: Readonly<ContourDrawerProps<T>>): HTMLElement => {\\n    //@ts-ignore\\n    return draw instanceof this.contentWindow['HTMLElement'] ? (draw as HTMLElement) : (this.svg as HTMLElement);\\n  };\\n\\n  canActivate = ({ draw }: Readonly<ContourDrawerProps<T>>) => {\\n    return draw instanceof this.contentWindow['HTMLElement'] || draw === true;\\n  };\\n\\n  // ---------------------------------------------\\n  // initial events\\n  // ---------------------------------------------\\n  activateInitialEvents = () => {\\n    if (!this.element) return;\\n    if (this.props.device !== 'touch-only' && this.props.device !== 'stylus-only') {\\n      this.element.addEventListener('mousemove', this.onMouseMoveToFindFocus);\\n      this.element.addEventListener('mousedown', this.onMouseDownToStartDraw);\\n    }\\n    if (isTouchDevice() && this.props.device !== 'mouse-only') {\\n      this.element.addEventListener('touchstart', this.onTouchStartToStartDraw);\\n    }\\n    this.element.addEventListener('click', this.onMouseClickToRemove);\\n  };\\n\\n  deactivateInitialEvents = () => {\\n    if (!this.element) return;\\n    this.element.removeEventListener('mousemove', this.onMouseMoveToFindFocus);\\n    this.element.removeEventListener('mousedown', this.onMouseDownToStartDraw);\\n    this.element.removeEventListener('touchstart', this.onTouchStartToStartDraw);\\n    this.element.removeEventListener('click', this.onMouseClickToRemove);\\n  };\\n\\n  onMouseMoveToFindFocus = (event: MouseEvent) => {\\n    event.stopPropagation();\\n\\n    this.findFocus(event.pageX, event.pageY);\\n  };\\n\\n  findFocus = (pageX: number, pageY: number) => {\\n    if (!this.props.contours || this.props.contours.length === 0 || !this.props.cornerstoneRenderData) return;\\n\\n    const element: HTMLElement = this.props.cornerstoneRenderData.element;\\n\\n    const { x, y } = cornerstone.pageToPixel(element, pageX, pageY);\\n\\n    this.focused = hitTestContours<T>(this.props.contours, [x, y]);\\n\\n    this.props.onFocus(this.focused);\\n  };\\n\\n  onMouseClickToRemove = (event: MouseEvent) => {\\n    event.stopPropagation();\\n\\n    if (!this.focused || this.preventClickEvent) return;\\n\\n    this.props.onRemove(this.focused);\\n  };\\n\\n  // ---------------------------------------------\\n  // touch draw events\\n  // ---------------------------------------------\\n  onTouchStartToStartDraw = (event: TouchEvent) => {\\n    if (\\n      (this.props.device === 'stylus-only' || this.props.device === 'mouse-and-stylus') &&\\n      event.targetTouches[0].touchType !== 'stylus'\\n    ) {\\n      return;\\n    } else if (event.targetTouches.length > 1) {\\n      this.deactivateTouchDrawEvents();\\n      this.activateInitialEvents();\\n      this.setState((prevState) => ({\\n        ...prevState,\\n        polygon: [],\\n      }));\\n      return;\\n    } else if (event.targetTouches.length !== 1) {\\n      return;\\n    }\\n\\n    event.preventDefault();\\n    event.stopPropagation();\\n    event.stopImmediatePropagation();\\n\\n    if (!this.props.cornerstoneRenderData) {\\n      throw new Error('cornerstoneRenderEventData를 찾을 수 없다!');\\n    }\\n\\n    this.preventClickEvent = false;\\n    this.startX = event.targetTouches[0].pageX;\\n    this.startY = event.targetTouches[0].pageY;\\n\\n    this.deactivateInitialEvents();\\n    this.activateTouchDrawEvents();\\n\\n    const element: HTMLElement = this.props.cornerstoneRenderData.element;\\n\\n    const { x, y } = cornerstone.pageToPixel(element, event.targetTouches[0].pageX, event.targetTouches[0].pageY);\\n\\n    this.setState((prevState) => ({\\n      ...prevState,\\n      polygon: [[x, y]],\\n    }));\\n  };\\n\\n  activateTouchDrawEvents = () => {\\n    if (!this.element) return;\\n    this.element.addEventListener('touchmove', this.onTouchMoveToDraw);\\n    this.element.addEventListener('touchend', this.onTouchEndToEndDraw);\\n    this.element.addEventListener('touchcancel', this.onTouchEndToEndDraw);\\n    window.addEventListener('keydown', this.onKeyDownToCancelTouchDraw);\\n  };\\n\\n  deactivateTouchDrawEvents = () => {\\n    if (!this.element) return;\\n    this.element.removeEventListener('touchmove', this.onTouchMoveToDraw);\\n    this.element.removeEventListener('touchend', this.onTouchEndToEndDraw);\\n    this.element.removeEventListener('touchcancel', this.onTouchEndToEndDraw);\\n    window.removeEventListener('keydown', this.onKeyDownToCancelTouchDraw);\\n  };\\n\\n  onTouchMoveToDraw = (event: TouchEvent) => {\\n    if (event.targetTouches.length !== 1 || event.changedTouches.length !== 1) {\\n      this.deactivateTouchDrawEvents();\\n      this.activateInitialEvents();\\n      this.setState((prevState) => ({\\n        ...prevState,\\n        polygon: [],\\n      }));\\n      return;\\n    }\\n\\n    event.preventDefault();\\n    event.stopPropagation();\\n    event.stopImmediatePropagation();\\n\\n    if (!this.props.cornerstoneRenderData) {\\n      throw new Error('cornerstoneRenderEventData를 찾을 수 없다!');\\n    }\\n\\n    if (\\n      !this.preventClickEvent &&\\n      Math.max(\\n        Math.abs(event.targetTouches[0].pageX - this.startX),\\n        Math.abs(event.targetTouches[0].pageY - this.startY),\\n      ) > 20\\n    ) {\\n      this.preventClickEvent = true;\\n    }\\n\\n    const element: HTMLElement = this.props.cornerstoneRenderData.element;\\n\\n    const { x, y } = cornerstone.pageToPixel(element, event.targetTouches[0].pageX, event.targetTouches[0].pageY);\\n\\n    this.setState((prevState) => ({\\n      ...prevState,\\n      polygon: [...prevState.polygon, [x, y]],\\n    }));\\n  };\\n\\n  onTouchEndToEndDraw = (event: TouchEvent) => {\\n    event.preventDefault();\\n    event.stopPropagation();\\n    event.stopImmediatePropagation();\\n\\n    this.deactivateTouchDrawEvents();\\n    this.activateInitialEvents();\\n\\n    this.props.onAdd(this.state.polygon, event);\\n\\n    this.setState((prevState) => ({\\n      ...prevState,\\n      polygon: [],\\n    }));\\n  };\\n\\n  onKeyDownToCancelTouchDraw = (event: KeyboardEvent) => {\\n    if (event.key.toLowerCase() === 'escape') {\\n      event.preventDefault();\\n      event.stopPropagation();\\n      event.stopImmediatePropagation();\\n\\n      this.cancelTouchDraw();\\n    }\\n  };\\n\\n  cancelTouchDraw = () => {\\n    this.deactivateTouchDrawEvents();\\n    this.activateInitialEvents();\\n\\n    this.setState((prevState) => ({\\n      ...prevState,\\n      polygon: [],\\n    }));\\n  };\\n\\n  // ---------------------------------------------\\n  // mouse draw events\\n  // ---------------------------------------------\\n  onMouseDownToStartDraw = (event: MouseEvent) => {\\n    event.preventDefault();\\n    event.stopPropagation();\\n    event.stopImmediatePropagation();\\n\\n    if (!this.props.cornerstoneRenderData) {\\n      throw new Error('cornerstoneRenderEventData를 찾을 수 없다!');\\n    }\\n\\n    this.preventClickEvent = false;\\n    this.startX = event.pageX;\\n    this.startY = event.pageY;\\n\\n    this.deactivateInitialEvents();\\n    this.activateMouseDrawEvents();\\n\\n    const element: HTMLElement = this.props.cornerstoneRenderData.element;\\n\\n    const { x, y } = cornerstone.pageToPixel(element, event.pageX, event.pageY);\\n\\n    this.setState((prevState) => ({\\n      ...prevState,\\n      polygon: [[x, y]],\\n    }));\\n  };\\n\\n  activateMouseDrawEvents = () => {\\n    if (!this.element) return;\\n    this.element.addEventListener('mousemove', this.onMouseMoveToDraw);\\n    this.element.addEventListener('mouseup', this.onMouseUpToEndDraw);\\n    this.element.addEventListener('mouseleave', this.onMouseLeaveToCancelDraw);\\n    window.addEventListener('keydown', this.onKeyDownToCancelMouseDraw);\\n  };\\n\\n  deactivateMouseDrawEvents = () => {\\n    if (!this.element) return;\\n    this.element.removeEventListener('mousemove', this.onMouseMoveToDraw);\\n    this.element.removeEventListener('mouseup', this.onMouseUpToEndDraw);\\n    this.element.removeEventListener('mouseleave', this.onMouseLeaveToCancelDraw);\\n    window.removeEventListener('keydown', this.onKeyDownToCancelMouseDraw);\\n  };\\n\\n  onMouseMoveToDraw = (event: MouseEvent) => {\\n    event.preventDefault();\\n    event.stopPropagation();\\n    event.stopImmediatePropagation();\\n\\n    if (!this.props.cornerstoneRenderData) {\\n      throw new Error('cornerstoneRenderEventData를 찾을 수 없다!');\\n    }\\n\\n    if (\\n      !this.preventClickEvent &&\\n      Math.max(Math.abs(event.pageX - this.startX), Math.abs(event.pageY - this.startY)) > 20\\n    ) {\\n      this.preventClickEvent = true;\\n    }\\n\\n    const element: HTMLElement = this.props.cornerstoneRenderData.element;\\n\\n    const { x, y } = cornerstone.pageToPixel(element, event.pageX, event.pageY);\\n\\n    this.setState((prevState) => ({\\n      ...prevState,\\n      polygon: [...prevState.polygon, [x, y]],\\n    }));\\n  };\\n\\n  onMouseUpToEndDraw = (event: MouseEvent) => {\\n    event.preventDefault();\\n    event.stopPropagation();\\n    event.stopImmediatePropagation();\\n\\n    this.deactivateMouseDrawEvents();\\n    this.activateInitialEvents();\\n\\n    this.props.onAdd(this.state.polygon, event);\\n\\n    this.setState((prevState) => ({\\n      ...prevState,\\n      polygon: [],\\n    }));\\n  };\\n\\n  onMouseLeaveToCancelDraw = (event: MouseEvent) => {\\n    event.preventDefault();\\n    event.stopPropagation();\\n    event.stopImmediatePropagation();\\n\\n    this.cancelMouseDraw();\\n  };\\n\\n  onKeyDownToCancelMouseDraw = (event: KeyboardEvent) => {\\n    if (event.key.toLowerCase() === 'escape') {\\n      event.preventDefault();\\n      event.stopPropagation();\\n      event.stopImmediatePropagation();\\n\\n      this.cancelMouseDraw();\\n    }\\n  };\\n\\n  cancelMouseDraw = () => {\\n    this.deactivateMouseDrawEvents();\\n    this.activateInitialEvents();\\n\\n    this.setState((prevState) => ({\\n      ...prevState,\\n      polygon: [],\\n    }));\\n  };\\n}\\n\\n/* eslint-disable @typescript-eslint/no-explicit-any */\\nexport const ContourDrawer: new <T extends Contour>() => ContourDrawerBase<T> = styled(ContourDrawerBase)`\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n\\n  --color: rgb(255, 224, 0);\\n  --stroke-width: 4px;\\n  --fill-color: rgba(255, 224, 0, 0.2);\\n\\n  > polyline:first-child {\\n    stroke: var(--contour-drawer-color, var(--color));\\n    stroke-width: var(--contour-drawer-stroke-width, var(--stroke-width));\\n    fill: var(--contour-drawer-fill-color, var(--fill-color));\\n  }\\n\\n  > polyline[data-highlight] {\\n    stroke: #ffffff;\\n    stroke-width: var(--contour-drawer-stroke-width, var(--stroke-width));\\n    fill: transparent;\\n    ${dashStroke}\\n  }\\n` as any;\\n\\n/**\\n * @deprecated use ContourDrawer instead\\n */\\nexport const UserContourDrawer = ContourDrawer;\\n\"","import {\n  CircleDrawer,\n  CircleViewer,\n  CornerstoneImage,\n  CornerstoneSingleImage,\n  CornerstoneViewer,\n  InsightViewerContainer,\n  InsightViewerControllerOptions,\n  InsightViewerTestController,\n  installWADOImageLoader,\n  unloadImage,\n  useContour,\n  useInsightViewerSync,\n} from '@lunit/insight-viewer';\nimport React, { useMemo } from 'react';\nimport { labelFunction } from '../../../__fixtures__/circle';\n\ninstallWADOImageLoader();\n\nconst controllerOptions: InsightViewerControllerOptions = {\n  width: [600, 400, 1000],\n  height: [700, 400, 1000],\n  control: ['pen', ['none', 'pan', 'pen', 'adjust']],\n  wheel: ['zoom', ['none', 'zoom']],\n  flip: [false],\n  invert: [false],\n};\n\nexport default () => {\n  const image: CornerstoneImage = useMemo(\n    () =>\n      new CornerstoneSingleImage(`wadouri:https://fixtures.front.lunit.io/dcm-files/series/CT000010.dcm`, {\n        unload: unloadImage,\n      }),\n    [],\n  );\n\n  const { cornerstoneRenderData, updateCornerstoneRenderData } = useInsightViewerSync();\n\n  // create contour data and user drawing behaviors\n  const { contours, focusedContour, addContour, removeContour, focusContour } = useContour({\n    mode: 'circle',\n  });\n\n  return (\n    <InsightViewerTestController options={controllerOptions}>\n      {({ width, height, invert, flip, control, resetTime, interactions, setElement, element }) => (\n        <InsightViewerContainer ref={setElement} width={width} height={height}>\n          <CornerstoneViewer\n            width={width}\n            height={height}\n            invert={invert}\n            flip={flip}\n            interactions={interactions}\n            resetTime={resetTime}\n            image={image}\n            updateCornerstoneRenderData={updateCornerstoneRenderData}\n          />\n          {contours && contours.length > 0 && cornerstoneRenderData && (\n            <CircleViewer\n              width={width}\n              height={height}\n              contours={contours}\n              focusedContour={focusedContour}\n              cornerstoneRenderData={cornerstoneRenderData}\n            />\n          )}\n          {contours && cornerstoneRenderData && control === 'pen' && element && (\n            <CircleDrawer\n              width={width}\n              height={height}\n              contours={contours}\n              draw={control === 'pen' && element}\n              onFocus={focusContour}\n              onAdd={(contour) => addContour(contour, { label: labelFunction })}\n              onRemove={removeContour}\n              cornerstoneRenderData={cornerstoneRenderData}\n            />\n          )}\n        </InsightViewerContainer>\n      )}\n    </InsightViewerTestController>\n  );\n};\n","export default \"import {\\n  CircleDrawer,\\n  CircleViewer,\\n  CornerstoneImage,\\n  CornerstoneSingleImage,\\n  CornerstoneViewer,\\n  InsightViewerContainer,\\n  InsightViewerControllerOptions,\\n  InsightViewerTestController,\\n  installWADOImageLoader,\\n  unloadImage,\\n  useContour,\\n  useInsightViewerSync,\\n} from '@lunit/insight-viewer';\\nimport React, { useMemo } from 'react';\\nimport { labelFunction } from '../../../__fixtures__/circle';\\n\\ninstallWADOImageLoader();\\n\\nconst controllerOptions: InsightViewerControllerOptions = {\\n  width: [600, 400, 1000],\\n  height: [700, 400, 1000],\\n  control: ['pen', ['none', 'pan', 'pen', 'adjust']],\\n  wheel: ['zoom', ['none', 'zoom']],\\n  flip: [false],\\n  invert: [false],\\n};\\n\\nexport default () => {\\n  const image: CornerstoneImage = useMemo(\\n    () =>\\n      new CornerstoneSingleImage(`wadouri:https://fixtures.front.lunit.io/dcm-files/series/CT000010.dcm`, {\\n        unload: unloadImage,\\n      }),\\n    [],\\n  );\\n\\n  const { cornerstoneRenderData, updateCornerstoneRenderData } = useInsightViewerSync();\\n\\n  // create contour data and user drawing behaviors\\n  const { contours, focusedContour, addContour, removeContour, focusContour } = useContour({\\n    mode: 'circle',\\n  });\\n\\n  return (\\n    <InsightViewerTestController options={controllerOptions}>\\n      {({ width, height, invert, flip, control, resetTime, interactions, setElement, element }) => (\\n        <InsightViewerContainer ref={setElement} width={width} height={height}>\\n          <CornerstoneViewer\\n            width={width}\\n            height={height}\\n            invert={invert}\\n            flip={flip}\\n            interactions={interactions}\\n            resetTime={resetTime}\\n            image={image}\\n            updateCornerstoneRenderData={updateCornerstoneRenderData}\\n          />\\n          {contours && contours.length > 0 && cornerstoneRenderData && (\\n            <CircleViewer\\n              width={width}\\n              height={height}\\n              contours={contours}\\n              focusedContour={focusedContour}\\n              cornerstoneRenderData={cornerstoneRenderData}\\n            />\\n          )}\\n          {contours && cornerstoneRenderData && control === 'pen' && element && (\\n            <CircleDrawer\\n              width={width}\\n              height={height}\\n              contours={contours}\\n              draw={control === 'pen' && element}\\n              onFocus={focusContour}\\n              onAdd={(contour) => addContour(contour, { label: labelFunction })}\\n              onRemove={removeContour}\\n              cornerstoneRenderData={cornerstoneRenderData}\\n            />\\n          )}\\n        </InsightViewerContainer>\\n      )}\\n    </InsightViewerTestController>\\n  );\\n};\\n\"","import {\n  CircleDrawer,\n  CircleViewer,\n  CornerstoneImage,\n  CornerstoneSingleImage,\n  CornerstoneViewer,\n  InsightViewerContainer,\n  InsightViewerControllerOptions,\n  InsightViewerTestController,\n  installWADOImageLoader,\n  unloadImage,\n  useContour,\n  useInsightViewerSync,\n} from '@lunit/insight-viewer';\nimport React, { useMemo } from 'react';\nimport styled from 'styled-components';\nimport { labelFunction } from '../../../__fixtures__/circle';\n\ninstallWADOImageLoader();\n\nconst controllerOptions: InsightViewerControllerOptions = {\n  width: [600, 400, 1000],\n  height: [700, 400, 1000],\n  control: ['pen', ['none', 'pan', 'pen', 'adjust']],\n  wheel: ['zoom', ['none', 'zoom']],\n  flip: [false],\n  invert: [false],\n};\n\nconst CustomStyleDrawer = styled(CircleDrawer)`\n  --contour-drawer-color: #ff0000;\n  --contour-drawer-fill-color: rgba(255, 255, 255, 0.4);\n  --contour-drawer-stroke-width: 7px;\n`;\n\nexport default () => {\n  const image: CornerstoneImage = useMemo(\n    () =>\n      new CornerstoneSingleImage(`wadouri:https://fixtures.front.lunit.io/dcm-files/series/CT000010.dcm`, {\n        unload: unloadImage,\n      }),\n    [],\n  );\n\n  const { cornerstoneRenderData, updateCornerstoneRenderData } = useInsightViewerSync();\n\n  // create contour data and user drawing behaviors\n  const { contours, focusedContour, addContour, removeContour, focusContour } = useContour({\n    mode: 'circle',\n  });\n\n  return (\n    <InsightViewerTestController options={controllerOptions}>\n      {({ width, height, invert, flip, control, wheel, resetTime, interactions, setElement, element }) => (\n        <InsightViewerContainer ref={setElement} width={width} height={height}>\n          <CornerstoneViewer\n            width={width}\n            height={height}\n            invert={invert}\n            flip={flip}\n            interactions={interactions}\n            resetTime={resetTime}\n            image={image}\n            updateCornerstoneRenderData={updateCornerstoneRenderData}\n          />\n          {contours && contours.length > 0 && cornerstoneRenderData && (\n            <CircleViewer\n              width={width}\n              height={height}\n              contours={contours}\n              focusedContour={focusedContour}\n              cornerstoneRenderData={cornerstoneRenderData}\n            />\n          )}\n          {contours && cornerstoneRenderData && control === 'pen' && element && (\n            <CustomStyleDrawer\n              width={width}\n              height={height}\n              contours={contours}\n              draw={control === 'pen' && element}\n              onFocus={focusContour}\n              onAdd={(contour) => addContour(contour, { label: labelFunction })}\n              onRemove={removeContour}\n              cornerstoneRenderData={cornerstoneRenderData}\n            />\n          )}\n        </InsightViewerContainer>\n      )}\n    </InsightViewerTestController>\n  );\n};\n","export default \"import {\\n  CircleDrawer,\\n  CircleViewer,\\n  CornerstoneImage,\\n  CornerstoneSingleImage,\\n  CornerstoneViewer,\\n  InsightViewerContainer,\\n  InsightViewerControllerOptions,\\n  InsightViewerTestController,\\n  installWADOImageLoader,\\n  unloadImage,\\n  useContour,\\n  useInsightViewerSync,\\n} from '@lunit/insight-viewer';\\nimport React, { useMemo } from 'react';\\nimport styled from 'styled-components';\\nimport { labelFunction } from '../../../__fixtures__/circle';\\n\\ninstallWADOImageLoader();\\n\\nconst controllerOptions: InsightViewerControllerOptions = {\\n  width: [600, 400, 1000],\\n  height: [700, 400, 1000],\\n  control: ['pen', ['none', 'pan', 'pen', 'adjust']],\\n  wheel: ['zoom', ['none', 'zoom']],\\n  flip: [false],\\n  invert: [false],\\n};\\n\\nconst CustomStyleDrawer = styled(CircleDrawer)`\\n  --contour-drawer-color: #ff0000;\\n  --contour-drawer-fill-color: rgba(255, 255, 255, 0.4);\\n  --contour-drawer-stroke-width: 7px;\\n`;\\n\\nexport default () => {\\n  const image: CornerstoneImage = useMemo(\\n    () =>\\n      new CornerstoneSingleImage(`wadouri:https://fixtures.front.lunit.io/dcm-files/series/CT000010.dcm`, {\\n        unload: unloadImage,\\n      }),\\n    [],\\n  );\\n\\n  const { cornerstoneRenderData, updateCornerstoneRenderData } = useInsightViewerSync();\\n\\n  // create contour data and user drawing behaviors\\n  const { contours, focusedContour, addContour, removeContour, focusContour } = useContour({\\n    mode: 'circle',\\n  });\\n\\n  return (\\n    <InsightViewerTestController options={controllerOptions}>\\n      {({ width, height, invert, flip, control, wheel, resetTime, interactions, setElement, element }) => (\\n        <InsightViewerContainer ref={setElement} width={width} height={height}>\\n          <CornerstoneViewer\\n            width={width}\\n            height={height}\\n            invert={invert}\\n            flip={flip}\\n            interactions={interactions}\\n            resetTime={resetTime}\\n            image={image}\\n            updateCornerstoneRenderData={updateCornerstoneRenderData}\\n          />\\n          {contours && contours.length > 0 && cornerstoneRenderData && (\\n            <CircleViewer\\n              width={width}\\n              height={height}\\n              contours={contours}\\n              focusedContour={focusedContour}\\n              cornerstoneRenderData={cornerstoneRenderData}\\n            />\\n          )}\\n          {contours && cornerstoneRenderData && control === 'pen' && element && (\\n            <CustomStyleDrawer\\n              width={width}\\n              height={height}\\n              contours={contours}\\n              draw={control === 'pen' && element}\\n              onFocus={focusContour}\\n              onAdd={(contour) => addContour(contour, { label: labelFunction })}\\n              onRemove={removeContour}\\n              cornerstoneRenderData={cornerstoneRenderData}\\n            />\\n          )}\\n        </InsightViewerContainer>\\n      )}\\n    </InsightViewerTestController>\\n  );\\n};\\n\"","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsx mdx */\nimport { component, source } from '@handbook/source';\nimport { Example } from '@handbook/components';\nimport { InsightViewerPreview } from '@lunit/handbook';\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <h1><inlineCode parentName=\"h1\">{`<CircleDrawer>`}</inlineCode></h1>\n    <p><inlineCode parentName=\"p\">{`<ContourDrawer>`}</inlineCode>{`와 마찬가지로 단순히 그리는 기능만 있고, 그려진 Contour 데이터들은 `}<inlineCode parentName=\"p\">{`<CircleViewer>`}</inlineCode>{`에서 처리해야 한다.`}</p>\n    <h1>{`API`}</h1>\n    <Example example={source('@lunit/insight-viewer/components/ContourDrawer')} api mdxType=\"Example\" />\n    <h1>{`Sample`}</h1>\n    <Example example={component('./CircleDrawer/Basic')} mdxType=\"Example\">\n  <InsightViewerPreview height={720} mdxType=\"InsightViewerPreview\" />\n    </Example>\n    <h1>{`Styling`}</h1>\n    <p><inlineCode parentName=\"p\">{`<ContourDrawer>`}</inlineCode>{`와 마찬가지로 CSS Variable을 통해서 색상을 변경할 수 있다.`}</p>\n    <p><inlineCode parentName=\"p\">{`<ContourDrawer>`}</inlineCode>{`와 마찬가지로 `}<inlineCode parentName=\"p\">{`--contour-drawer-*`}</inlineCode>{`의 이름을 가진 항목들에 영향을 받는다.`}</p>\n    <Example example={source('../../theme/style')} mdxType=\"Example\" />\n    <Example example={component('./CircleDrawer/CustomStyle')} mdxType=\"Example\">\n  <InsightViewerPreview height={720} mdxType=\"InsightViewerPreview\" />\n    </Example>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"],"sourceRoot":""}
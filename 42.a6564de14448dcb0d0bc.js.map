{"version":3,"sources":["webpack:///./src/_packages/@lunit/is-intersection/index.ts?f35f","webpack:///./src/_packages/@lunit/is-intersection/__tests__/isIntersection.test.ts","webpack:///./src/_packages/@lunit/is-intersection/__pages__/Basic.mdx"],"names":["layoutProps","MDXContent","components","props","mdxType","parentName","example","source","isMDXComponent"],"mappings":"2FAAA,OAAe,wiC,iCCAf,OAAe,+a,iCCCf,+EAOA,MAKMA,EAAc,GAIL,SAASC,GAAW,WACjCC,KACGC,IAEH,OAAO,YALS,UAKT,iBAAeH,EAAiBG,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAE5E,sBAAI,0BAAYC,WAAW,MAAO,2BAClC,qBAAK,QAAO,0BAAYA,WAAW,KAAM,MAAmB,WAAK,0BAAYA,WAAW,KAAM,MAAmB,mEACjH,YAAC,UAAD,CAASC,QAASC,YAAO,WAAD,UAAC,KAAD,2DAAcH,QAAQ,YAC9C,sBAAM,QACN,YAAC,UAAD,CAASE,QAASC,YAAO,mCAAD,UAAC,KAAD,mFAAsCH,QAAQ,aAK1EH,EAAWO,gBAAiB","file":"42.a6564de14448dcb0d0bc.js","sourcesContent":["export default \"type Point = [number, number];\\n\\n/**\\n * ab 와 cd 가 교차하는지 판정\\n * @param a line 1 start\\n * @param b line 1 end\\n * @param c line 2 start\\n * @param d line 2 end\\n */\\nexport function isIntersection(a: Point, b: Point, c: Point, d: Point): boolean {\\n  if (Math.max(a[0], b[0]) <= Math.min(c[0], d[0])) return false;\\n  if (Math.min(a[0], b[0]) >= Math.max(c[0], d[0])) return false;\\n  if (Math.max(a[1], b[1]) <= Math.min(c[1], d[1])) return false;\\n  if (Math.min(a[1], b[1]) >= Math.max(c[1], d[1])) return false;\\n\\n  const sign1: number = (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);\\n  const sign2: number = (b[0] - a[0]) * (d[1] - a[1]) - (d[0] - a[0]) * (b[1] - a[1]);\\n  const sign3: number = (d[0] - c[0]) * (a[1] - c[1]) - (a[0] - c[0]) * (d[1] - c[1]);\\n  const sign4: number = (d[0] - c[0]) * (b[1] - c[1]) - (b[0] - c[0]) * (d[1] - c[1]);\\n\\n  if (sign1 === 0 && sign2 === 0 && sign3 === 0 && sign4 === 0) return true;\\n  return sign1 * sign2 < 0 && sign3 * sign4 < 0;\\n}\\n\"","export default \"import { isIntersection } from '@lunit/is-intersection';\\n\\ndescribe('isIntersection()', () => {\\n  test('ab와 cd는 교차한다', () => {\\n    expect(isIntersection([0, 0], [10, 10], [10, 0], [0, 10])).toBeTruthy();\\n  });\\n\\n  test('ab와 cd는 교차하지 않는다', () => {\\n    expect(isIntersection([0, 0], [10, 0], [0, 10], [10, 10])).toBeFalsy();\\n  });\\n});\\n\"","\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsx mdx */\nimport { source } from '@handbook/source';\nimport { Example } from '@handbook/components';\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <h1><inlineCode parentName=\"h1\">{`@lunit/is-intersection`}</inlineCode></h1>\n    <p>{`Line `}<inlineCode parentName=\"p\">{`ab`}</inlineCode>{` 와 `}<inlineCode parentName=\"p\">{`cd`}</inlineCode>{`과 교차하는지 검사한다.`}</p>\n    <Example example={source('../index')} mdxType=\"Example\" />\n    <h1>{`Test`}</h1>\n    <Example example={source('../__tests__/isIntersection.test')} mdxType=\"Example\" />\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"],"sourceRoot":""}
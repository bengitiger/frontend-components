{"version":3,"sources":["webpack:///./src/_packages/@lunit/insight-viewer/__pages__/Basic/Contour.mdx"],"names":["layoutProps","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"2FACA,gEAMA,MAKMA,EAAc,GAIL,SAASC,GAAW,WACjCC,KACGC,IAEH,OAAO,YALS,UAKT,iBAAeH,EAAiBG,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAC5E,sBAAI,0BAAYC,WAAW,MAAO,sBAClC,qBAAK,qDACL,qBAAK,uOACL,8BACE,iBAAGA,WAAW,cAAe,+IAAoD,kBAAIA,WAAW,MAAW,KAC7G,2MAAwE,kBAAIA,WAAW,MAAW,KAClG,oLAAiD,kBAAIA,WAAW,MAAW,KAC3E,mHAAkC,0BAAYA,WAAW,KAAM,WAAwB,gDAEvF,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBACV,kxCA6BP,sBAAI,0BAAYA,WAAW,MAAO,WAAwB,uBAC1D,qBAAG,0BAAYA,WAAW,KAAM,mBAAgC,WAAK,0BAAYA,WAAW,KAAM,kBAA+B,KAAI,0BAAYA,WAAW,KAAM,iBAA8B,wBAAQ,0BAAYA,WAAW,KAAM,WAAwB,6DAAe,0BAAYA,WAAW,KAAM,sBAAmC,0GAC5U,sBACE,kBAAIA,WAAW,MAAK,0BAAYA,WAAW,MAAO,0DAAuE,sFACzH,kBAAIA,WAAW,MAAK,0BAAYA,WAAW,MAAO,6DAA0E,4GAC5H,kBAAIA,WAAW,MAAK,0BAAYA,WAAW,MAAO,qCAAkD,yGAEtG,sBAAM,0EACN,qBAAG,+BAAGA,WAAW,KAAQ,CACrB,KAAQ,mGACL,mGACP,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBACV,m7EAsDP,qBAAK,+FAAuC,0BAAYA,WAAW,KAAM,WAAwB,+EAAkB,kBAAIA,WAAW,MAAW,KAC7I,IAAG,0BAAYA,WAAW,KAAM,WAAwB,qGACxD,qBAAG,+BAAGA,WAAW,KAAQ,CACrB,KAAQ,qHACL,qHACP,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBACV,gRAWP,qBAAK,iDAAa,0BAAYA,WAAW,KAAM,uBAAoC,8IACnF,qBAAK,6BAAQ,0BAAYA,WAAW,KAAM,cAA2B,+UACrE,sBAAM,8DACN,iBAAQ,CACN,UAAa,sBAEb,gCAAIA,WAAW,MAAS,CACtB,UAAa,mBACZ,mCAAOA,WAAW,MAAS,CAC1B,KAAQ,WACR,SAAW,EACX,UAAY,KACD,IAAK,gEAM1BJ,EAAWK,gBAAiB","file":"47.40e1e17d9238929bb8b4.js","sourcesContent":["\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1><inlineCode parentName=\"h1\">{`interface Contour`}</inlineCode></h1>\n    <p>{`Annotation 데이터가 된다.`}</p>\n    <p>{`직접 사용하지 말고, 상속해서 프로젝트 내용에 맞는 Annotation을 정의한 다음 사용하도록 한다.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Application Data Modeling에 관련된 내용이기 때문에 쉽지 않을 수 있음`}<br parentName=\"p\"></br>{`\n`}{`Annotation Tool, OPT 모두 사용자가 Pen Annotation으로 화면에 병변을 그린다는 전제를 가지고 있고,`}<br parentName=\"p\"></br>{`\n`}{`해당 Annotation (병변)에 부가 정보를 입력한다는 구성을 가지고 있기 때문에`}<br parentName=\"p\"></br>{`\n`}{`사용자 Annotation이 들어가는 프로젝트의 경우 이 `}<inlineCode parentName=\"p\">{`Contour`}</inlineCode>{` Type을 이해해야 함`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`/** \n * UserContoureViewer와 같은 곳에서 사용된다\n * \n * Annotation Tool, OPT 등 Annotation을 해야 하는 상황에서 데이터가 된다.\n * \n * 직접 사용하지 말고, 내부적으로 상속해서 새로운 데이터를 생성해야 한다.\n */\nexport interface Contour {\n  /** 일종의 label 역할을 한다 */\n  id: number;\n\n  /**\n   * Mode에 따라 사용하는 방식이 다르다\n   * - (mode: contour) = [[x, y], [x, y], [x, y]...]\n   * - (mode: circle) = [[centerX, centerY][radius, ]]\n   * - (mode: point) = [[x, y]]\n   */\n  polygon: Point[];\n\n  /** 존재하는 경우 id 대신 출력된다 */\n  label?: ((contour: this) => string) | string;\n\n  /**\n   * svg element에 data-* 형식의 attribute를 넣어주게 된다.\n   * 해당 attribute들을 기준으로 css styling과 같은 기능들을 구현할 수 있다.\n   */\n  dataAttrs?: { [attr: string]: string };\n}\n`}</code></pre>\n    <h1><inlineCode parentName=\"h1\">{`polygon`}</inlineCode>{`의 유형`}</h1>\n    <p><inlineCode parentName=\"p\">{`<ContourViewer>`}</inlineCode>{` 와 `}<inlineCode parentName=\"p\">{`<CircleViewer>`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`<PointViewer>`}</inlineCode>{` 모두 이 `}<inlineCode parentName=\"p\">{`Contour`}</inlineCode>{` 데이터를 사용하지만, `}<inlineCode parentName=\"p\">{`[number, number][]`}</inlineCode>{` 구조의 배열을 사용하는 방식이 다르다.`}</p>\n    <ul>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`<ContourViewer contours={[[x, y], [x, y], [x, y]...]}>`}</inlineCode>{` Point(x, y)의 배열로서 Polygon을 사용한다`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`<CircleViewer contours={[[centerX, centerY][radius, ]]}}>`}</inlineCode>{` Center Point(x, y) 와 반지름 (Radius)으로 Circle을 사용한다`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`<PointViewer contours={[[x, y]]}>`}</inlineCode>{` Point(x, y) 하나만 존재하는 배열을 사용한다`}</li>\n    </ul>\n    <h1>{`CXR OPT (MGH 2020 연구)의 Annotation Modeling 사례`}</h1>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"https://github.com/lunit-io/cxr-opt-frontend-2002-mgh/blob/develop/src/app/model/annotation.ts\"\n      }}>{`https://github.com/lunit-io/cxr-opt-frontend-2002-mgh/blob/develop/src/app/model/annotation.ts`}</a></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { Contour } from '@lunit/insight-viewer';\n\n/** Classification의 Enumeration Values */\nexport const classifications = ['TP', 'FP', 'FN'] as const;\n\n/** Lesion의 Enumeration Values - MGH OPT 연구에서는 단순히 Nodule과 Nodule이 아닌 것으로 2가지 병변만 구분한다  */\nexport const lesions = ['nodule', 'non-nodule'] as const;\n\nexport type Classification = typeof classifications[number];\nexport type Lesion = typeof lesions[number];\n\nexport const classificationLabels = {\n  TP: 'True Positive',\n  FP: 'False Positive',\n  FN: 'False Negative',\n} as const;\n\nexport const lesionLabels = {\n  nodule: 'Nodule',\n  'non-nodule': 'Other findings',\n} as const;\n\n/**\n * Annotation의 부가 정보\n */\nexport interface AnnotationInfo {\n  /**\n   * GT, RT 모두에서 Annotation이 어떤 병변에 속하는지를 지정하는데 사용한다\n   * GT, RT 모두에서 Pen으로 Annotation을 그리고 난 뒤, 화면에 등장하는 Dialog 로 확인할 수 있다.\n   */\n  lesion: Lesion;\n\n  /**\n   * GT 에서 Annotation의 유형을 지정하는데 사용된다\n   * GT 에서 Pen으로 Annotation을 그리고 난 뒤, 화면에 등장하는 Dialog 로 확인할 수 있다.\n   */\n  classification?: Classification;\n\n  /**\n   * RT 에서 Annotation에 대한 의사의 확신도를 지정하는데 사용된다\n   * RT 에서 Pen으로 Annotation을 그리고 난 뒤, 화면에 등장하는 Dialog 로 확인할 수 있다.\n   */\n  confidenceLevel?: number; // 0 ~ 1 // RT 에서만 사용됨\n}\n\n/**\n * 현재 Application에서 사용되는 Annotation Model\n *\n * AnnotationInfo & Contour 의 합집합 유형이 된다\n *\n * <ContourDrawer>, <ContourDrawer> 를 비롯한 모든 Annotation 관리 Component에서 사용된다.\n */\nexport interface Annotation extends AnnotationInfo, Contour {}\n`}</code></pre>\n    <p>{`위와 같이 Application에서 사용되는 Annotation을 `}<inlineCode parentName=\"p\">{`Contour`}</inlineCode>{` 데이터를 사용해서 정의한다.`}<br parentName=\"p\"></br>{`\n`}{`(`}<inlineCode parentName=\"p\">{`Contour`}</inlineCode>{` 데이터를 직접 사용하지 않도록 한다.)`}</p>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"https://github.com/lunit-io/cxr-opt-frontend-2002-mgh/blob/develop/src/app/pages/ground-truth/case/index.tsx#L71\"\n      }}>{`https://github.com/lunit-io/cxr-opt-frontend-2002-mgh/blob/develop/src/app/pages/ground-truth/case/index.tsx#L71`}</a></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`  const {\n    contours,\n    addContour: _addContour,\n    addContours,\n    updateContour: _updatecontour,\n    removeContour: _removeContour,\n    removeAllContours: _removeAllContours,\n    focusContour,\n    focusedContour,\n  } = useUserContour<Annotation>();\n`}</code></pre>\n    <p>{`그리고, 이와 같이 `}<inlineCode parentName=\"p\">{`useUserContour<T>()`}</inlineCode>{`에 Generic으로 Annotation 유형을 넘겨서 Application이 동작되도록 한다.`}</p>\n    <p>{`이와 같은 `}<inlineCode parentName=\"p\">{`Annotation`}</inlineCode>{` Data Modeling은 Application 전반적으로 Type을 일관화 시킴으로서, 개발자의 Coding 실수로 인해 발생할 수 있는 모든 종류의 Error 발생을 방지시킬 수 있다.`}</p>\n    <h1>{`CXR Annotation Tool의 Annotation Modeling 사례`}</h1>\n    <ul {...{\n      \"className\": \"contains-task-list\"\n    }}>\n      <li parentName=\"ul\" {...{\n        \"className\": \"task-list-item\"\n      }}><input parentName=\"li\" {...{\n          \"type\": \"checkbox\",\n          \"checked\": false,\n          \"disabled\": true\n        }}></input>{` `}{`프로젝트 종료 후 추가 `}</li>\n    </ul>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"],"sourceRoot":""}